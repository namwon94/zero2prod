테스트 격리를 보장하기 위해 구성을 무작위화 하기위해 새로 구성(20250205) /tests/api/help.rs - spawn_app() 부분
    
    let listener = TcpListener::bind("127.0.0.1:0")
        .expect("Failed to bind random port");
    //OS가 할당한 포트 번호를 추출한다.
    let port = listener.local_addr().unwrap().port();
    let address = format!("http://127.0.0.1:{}", port);
    let mut configuration = get_configuration().expect("Failed to read configuration,");
    configuration.database.database_name = Uuid::new_v4().to_string();

    let connection_pool = configure_database(&configuration.database)
        .await;

    let sender_email = configuration.email_client.sender()
        .expect("Invalid sender email address");
    let timeout = configuration.email_client.timeout();
    let email_client = EmailClient::new(
        configuration.email_client.base_url,
        sender_email,
        configuration.email_client.authorization_token,
        timeout
    );
    let server = run(listener, connection_pool.clone(), email_client)
        .expect("Failed to bind address");
    let _ = tokio::spawn(server);
    TestApp {
        address,
        db_pool: connection_pool
    }

/routes/subscriptions subscribe 부분 20250203 / p246 / 리팩토링
//'web::Form'은 'FormData'의 래퍼이다. 'form.0'을 사용하면 기반 'FormData'에 접근할 수 있다.
    
    let name = match SubscriberName::parse(form.0.name){
        Ok(name) => name,
        //name이 유효하지 않으면 400을 빠르게 반환한다.
        Err(_) => return HttpResponse::BadRequest().finish()
    };
    let email = match SubscriberEmail::parse(form.0.email) {
        Ok(email) => email,
        Err(_) => return HttpResponse::BadRequest().finish()
    };
    let new_subscriber = NewSubscriber {
        email,
        name
    };

/routes/subscriptions subscriber 부분 20250206 / 리팩토링
    //'Result'는 'Ok'와 'Err'라는 두개의 변형(variant)를 갖는다.(성공과 실패 의미)
    //'match' 구문을 사용해서 결과에 따라 무엇을 수행할지 선택한다.
     match insert_subscriber(&pool, &new_subscriber).await {
         Ok(_) => {
             tracing::info!("New subscriber details have been saved");
             HttpResponse::Ok().finish()
         },
         Err(e) => {
             //우리가 기대한 대로 작동하지 않은 경우, println을 사용해서 오류에 관한 정보를 잡아낸다.
             //println!("Failed to execute query: {}", e);
             tracing::error!("failed to execute query: {}", e);
             HttpResponse::InternalServerError().finish()
         }
     }
     
/routes/subscriptions
//입력이 subscriber 이름에 대한 검증 제약 사항을 모두 만족하면 'true'를 반환한다.
//그렇지 않으면 'false'를 반환한다.
/* 
pub fn is_valid_name(s: &str) -> bool {
    //'.trim()'은 입력 's'에 대해 뒤로 계속되는 공백 문자가 없는 뷰를 반환한다.
    //'.is_empty'는 해당 뷰가 문자를 포함하고 있는지 확인한다.
    let is_empty_or_whitespace = s.trim().is_empty();
    //grapheme는 "사용자가 인지할 수 있는" 문자로서 유니코드 표준에 의해 정의된다.
    //'a'는 단일 grapheme이지만, 두 개의 문자가 조합된 것이다. (a 와 *)
    //grapheme 입력 's'안의 grapheme에 대한 이터레이터를 반환한다.
    //'true'는 우리가 확장된 grapheme 정의 셋, 즉 권장되는 정의 셋을 사용하기 원함을 의미한다.
    let is_too_long = s.graphemes(true).count() > 256;

    //입력 's'의 모든 문자들에 대해 반복하면서 forbidden 배열  안에 있는 문자 중, 어느 하나와 일치하는 문자가 있는지 확인한다.
    let forbidden_characters = ['/', '(', ')', '"', '<', '>', '\\', '{', '}'];
    let contains_forbidden_characters = s
        .chars()
        .any(|g| forbidden_characters.contains(&g));

    //어떤 한 조건이라도 위반하면 'false'를 반환한다.
    !(is_empty_or_whitespace || is_too_long || contains_forbidden_characters)
}
*/

//20250213 /routes/subscriptions / Error 트레이트 구현으로 인한 수정 전
pub async fn subscribe(
    form: web::Form<FormData>, 
    pool: web::Data<PgPool>,
    //20250206 추가 - 앱 콘테스트에서 이메일 클라이언트를 얻는다.
    email_client: web::Data<EmailClient>,
    //20250211 추가 - 도메인 전달 -> 도메인과 프로토콜은 애플리케이션이 실행되는 환경에 따라 다르기 때문에 새로 추가
    base_url: web::Data<ApplicationBaseUrl>
) -> HttpResponse {
    let new_subscriber = match form.0.try_into() {
        Ok(form) => form,
        Err(_) => return HttpResponse::BadRequest().finish()
    };
    let mut transaction = match pool.begin().await {
        Ok(transaction) => transaction,
        Err(_) => return HttpResponse::InternalServerError().finish()
    };
    let subscriber_id = match insert_subscriber(&mut transaction, &new_subscriber).await {
        Ok(subscriber_id) => subscriber_id,
        Err(_) => return HttpResponse::InternalServerError().finish()
    };
    let subscription_token = generate_subscription_token();
    if store_token(&mut transaction, subscriber_id, &subscription_token).await.is_err() {
        return HttpResponse::InternalServerError().finish();
    }
    if transaction.commit().await.is_err() {
        return HttpResponse::InternalServerError().finish();
    }
    //20250211 - 애플리케이션 url을 전달한다.
    if send_confirmation_email(&email_client, new_subscriber, &base_url.0, &subscription_token).await.is_err() {
        return HttpResponse::InternalServerError().finish();
    }
    HttpResponse::Ok().finish()
    
    //(쓸모없는) 이메일을 신규 가입자에게 전송한다. 지금은 이메일 전송 오류는 무시한다.
}

20250219 수정 / 10장 인증 / 아직 편집자들을 위한 가입 플로가 구현이 안되어 있으면 완전한 블랙 박스 접근 방식을 사용
TestApp {
        //20250211 수정
        address: format!("http://localhost:{}", application_port),
        //20250211 추가
        port: application_port,
        db_pool: get_connection_pool(&configuration.database),
        email_server
    }

20250304 수정 / 10장 인증 / 기존 src/newsletters를 src/routes/admin/newletter로 옮기면서 수정된 부분 -> 처음 newsletters를 만들 때 오류 부분을 이 형식으로 구현 
fn basic_authentication(headers: &HeaderMap) -> Result<Credentials, anyhow::Error> {
    //헤더값이 존재한다면 유효한 UTF8문자열이어야 한다.
    let header_value = headers
        .get("Authorization")
        .context("The 'Authorization' header was missing")?
        .to_str()
        .context("The 'Authorization' header was not a valid UTF8 string")?;
    let base64encoded_segment = header_value
        .strip_prefix("Basic ")
        .context("The authorization scheme was not 'Basic'.")?;
    let decoded_bytes = base64::decode_config(base64encoded_segment, base64::STANDARD)
        .context("Failed to base64-decode 'Basic' credentials.")?;
    let decoded_credentials = String::from_utf8(decoded_bytes)
        .context("The decoded credential string is not valid UTF8.")?;

    //':' 구분자를 사용해서 두 개의 세그먼트로 나눈다.
    let mut credentials = decoded_credentials.splitn(2, ':');
    let username = credentials
        .next()
        .ok_or_else(|| {
            anyhow::anyhow!("A username must be provided in 'Basic' auth.")
        })?
        .to_string();
    let password = credentials
        .next()
        .ok_or_else(|| {
            anyhow::anyhow!("A password must be provided in 'Basic' auth.")
        })?
        .to_string();

    Ok(Credentials {
        username,
        password: Secret::new(password)
    })
}

#[derive(thiserror::Error)]
pub enum PublishError {
    #[error(transparent)]
    UnexpectError(#[from] anyhow::Error),
    //20250219 추가 / 인증에 관련되 에러
    #[error("Authentication failed")]
    AuthError(#[source] anyhow::Error)
}

//같은 로직을 사용해서 'Debug'에 대한 모든 오류 체인을 얻는다.
impl std::fmt::Debug for PublishError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        error_chain_fmt(self, f)
    }
}

//20250219 수정
impl ResponseError for PublishError {
    fn error_response(&self) -> HttpResponse {
        match self {
            PublishError::UnexpectError(_) => {
                HttpResponse::new(StatusCode::INTERNAL_SERVER_ERROR)
            }
            //인증 오류에 대해 401을 반환한다.
            PublishError::AuthError(_) => {
                let mut response = HttpResponse::new(StatusCode::UNAUTHORIZED);
                let header_value = HeaderValue::from_str(r#"Basic realm="publish""#)
                    .unwrap();
                response
                    .headers_mut()
                    //actix_web::http:header는 여러 잘 알려진/표준 HTTP 헤더의 이름에 관한 상수 셋을 제공한다.
                    .insert(header::WWW_AUTHENTICATE, header_value);
                response
            }
        }
    }

    //'status_code'는 기본 'error_response' 구현에 의해 호출된다.
    //맞춤형의 'error_response' 구현을 제공하므로, 'status_code' 구현을 더 이상 유지할 필요가 없다.
}