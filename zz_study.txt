######20250116######
클라우드 네이티브 : 클라우드 컴퓨팅 환경에서 현대적인 애플리케이션을 구축, 배포 및 관리하는 소프트웨어 접근 방식입니다

*** main.rs 구문 ***

use actix_web::{web, App, HttpRequest, HttpServer, Responder};

async fn greet(req: HttpRequest) -> impl Responder {
    let name = req.match_info().get("name").unwrap_or("World");
    format!("Hello!!!! {}!", &name)
}

#[tokio:: main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/", web::get().to(greet))
            .route("/{name}", web::get().to(greet))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

HttpServer 의 역할 : 모든 전송 계층의 고려 사항을 처리한다 
    -> ( ex. 애플리케이션이 유입되는 요청을 어디서 받는가? / 허가 할 수 있는 동시 연결의 최대수(단위 시간당 얼마나 많은 신규 커넥션을 유지 한는가) / 전송 계층 보안 활성화 등 )

App의 역할 : 애플리케이션 로직(라우팅, 미들웨어, 요청 핸들러) 동작 하는 곳. 유입요청을 입력으로 받아 응답을 출력하는 컴포넌트
    -> App에 새로운 앤드포인트를 추가하는 방법
        : 간단한 방법 -> "route" 사용 
            -> route는 두개의 파라미터 받음, 하나의 핸들러(handler)와 일련의 가드(guard) 조합 
            ( path : 문자열이며 동적 경로 세그먼트를 수용하기 위해 템플릿화 ex."/{name}" , route : Route 구조체의 인스턴스 )
            , 가드는 핸들러에 전달되기 위해 만족할 수 있고 여청이 일치하는 조건을 지정 ( Guard 트레이드 )
                , .route("/", web::get().to(great))의 의미 
                    : "/"는 베이스경로에 아무런 세그먼트를 갖지 않는 모든 요청과 일치한다.
                    web::get().to(great)는 Route::new().guard(guard:Get())를 간략하게 표현한것 즉 요청은 GET일때만 핸들어에 전달되어야함
            , 핸들러 일단은 예시로 greet( 비동기 함수, HttpRequest를 입력받아 Responder 트레이트를 구현한 무언가를 반환, 타입은 HttpRespomse로 변환할 수 있을때만 구현 )만 사용

런타임: tokio (절차적 매크로 procedural macro)
    : 비동기 트로그래밍은 Future trait위에 만들어짐 -> 모든 퓨처는 하나의 poll메서드를 노출 이를 호출 시 퓨처가 진행되어 최종값을 갖게됨
    , main은 비동기여야 한다(HttpServer::run은 비동기 메서드이기 때문) 하지만 바이너리의 엔트리 포인트인 main은 비동기 함수가 될수 없음
        -> 이유 : 설계상 러스트의 표준 라이브러리는 비동기적인 런타임을 포함하지 않음 의존성을 추가해야 된다면 Cargo.toml 아래에 하나 이상의 크레이트를 추가해야됨, 유스케이스의 측정한 요구 사항에 최적화된 런타임 직접 구현 가능
        -> 이러한 이유로 main은 비동기 함수가 될수 없음

리그레션 : 새로운 기능의 추가 혹은 수정으로 인해 과거에 개발한 기능의 동작에 이상이 발생하는 것을 나타낸다

블랙박스테스트 : 주어진 입력값에 대한 출력값을 확인함으로써 시스템의 동작을 검증

라이브러리 와 바이너리 
        cargo의 기본동작은 다른 코드를 추가하지 않으면 src/main.rs파일을 바이너리 엔트리 포은트로 검색하고, package.name 필드를 바이너리 이름으로 사용
        
Rust 바이너리의 엔트리 포인트는 프로그램 실행이 시작되는 지점을 의미합니다.

Rust에서 라이브러리와 바이너리 프로젝트를 리팩토링할 때 고려해야 할 몇 가지 중요한 사항들이 있습니다:
구조 개선
    -> 관심사 분리: main 함수에서 여러 작업을 수행하는 대신, 로직을 lib.rs로 옮기고 main.rs는 설정과 실행에만 집중하도록 합니다
    -> 모듈화: 기능별로 코드를 모듈로 분리하여 유지보수성을 높입니다. 단, 과도한 중첩은 피하고 필요에 따라 점진적으로 모듈을 나눕니다
    -> 공개 API 설계: 라이브러리 사용자를 위해 간단하고 평평한 네임스페이스를 제공하되, 내부 구현은 계층적으로 구성할 수 있습니다
코드 품질 향상
    -> 트레이트 활용: 복잡한 트레이트 바운드는 피하고, 필요한 경우에만 적절히 사용합니다
    -> 매크로 사용 제한: 보일러플레이트 코드에만 매크로를 사용하고, 과도한 사용은 피합니다
    -> clone 사용: 성능에 큰 영향이 없다면, 복잡한 라이프타임 처리보다 clone을 사용하는 것이 코드 가독성을 높일 수 있습니다
도구 활용
    -> rustfmt와 clippy 사용: 일관된 코드 스타일을 유지하고 일반적인 실수를 방지합니다
    -> IDE 리팩토링 도구 활용: 변수나 함수 이름 변경 시 IDE의 리팩토링 기능을 사용하여 안전하게 변경합니다
점진적 접근
    -> 큰 변경은 점진적으로 수행: 필요성을 발견하면 먼저 리팩토링을 통해 교체를 쉽게 만들고, 그 후에 변경을 적용합니다
    -> ㅍ테스트 작성: 리팩토링 전후로 테스트를 작성하여 기능이 올바르게 동작하는지 확인합니다.

테스트 작성 ( 총 3가지)
    1. 내장 테스트 모듈 사용 ( 코드 옆에 작성 ) -> #[cfg(test)] 선언 -> 가까이 있는 코드 접근에 대한 특권을 가짐 / 의존성으로 임포트 시 코드 사용자들에게 보이지 않음
    2. 외부 test 폴더에 작성              
    3. 공개 문서의 일부로 작성(doc test)

#####20250118#####
테이블 주도 테스트(파라미터화 테스트)

추출자 (actix-web 사용자가이드) : 유입되는 요청으로부터 특정한 정보를 추출하도록 프레임워크에게 지시할 때 사용

serde : 러스트 데이터 구조를 효율적이고 제네릭하게 직력화/역직렬화하기 위한 프레임워크
    -> 내가 구현한 타입이 Serialize를 일단 구현하면, Serializer의 구체적인 구현을 사용해서 실제로 직렬화 단계를 수행할 수 있다 (어떤 포맷이든지)
    -> 단일화 라고 불리는 프로세스 덕분에 효율적으로 사용할 수 있다.

#####20250120#####
PostgressSQL -> 관계형 데이터베이스
    -> tokio-postgres : 런타임에 쿼리를 실행시 오류 발생확인 (쿼리 직접 기술 -> 비동기 인터페이스)
    -> sqlx : 사용자 절차 매크로를 사용해서 컴파일-시간에 데이터베이스에 연결하고 제공된 퀄리가 실제로 올바른지 확인 (쿼리 직접 기술 -> 비동기 인터페이스)
    -> diesel : CLI를 활요해서 데이터베이스 스키마 표현을 러스트 코드처럼 생성 이를 활요해 쿼리에 대한 가정을 확인 (고유한 쿼리 필터 제공 -> 도메인 특화 언어 -> 동기 인터페이스)

데이터 마이그레이션 : 데이터베이스에 새로운 테이블을 추가하려면 스키마를 변경

마이그레이션 생성 하는 명령어
export DATABASE_URL=postgres://postgrfes:password@127.0.0.1:5432/newsletter
sqlx migrate add create_subscriptions_table

#####20250121#####
let mut #name# mut의 의미 : 변수가 가변임을 명시적으로 선언 -> rust에서 변수는 기본적으로 불변 이므로 변수가 가변으로 선언이 필요할 경우 mut를 사용한다.

PgConnection::connect : 단일 연결 문자열을 입력받음 / DatabaseSettings : 모든 연결 파라미터에 각각 접근 가능

sqlx : sqlx_cli 명령어와 마찬가지로, DATABASE_URL 환경변수에 의존해서 데이터베이스의 위치를 찾는다. 
    -> DATABASE_URL은 수동으로 익스포트할 수 있다. 하지만 머신을 부팅하고 프로잭트에서 작업을 시작할 때마다 같은 작업을 해야 한다
    -> 그러므로 최상위 레벨의 .env 파일에 다음을 추가한다.


PgConnection의 동시성 이슈 -> sqlx은 비동기 인터페이스 하지만 같은 데이터베이스 커넥션에 대해 동시에 여러 쿼리를 실행할 수 없다.

Rust에서 pub struct는 공개(public) 구조체를 선언하는 키워드입니다.
    -> 가시성: pub 키워드는 해당 구조체를 모듈 외부에서 접근 가능하게 만듭니다. 이는 다른 모듈이나 크레이트에서 이 구조체를 사용할 수 있음을 의미합니다.
    -> 데이터 캡슐화: 구조체 자체는 공개되지만, 구조체의 필드는 기본적으로 비공개(private)입니다. 필드를 공개하려면 각 필드에 pub 키워드를 추가해야 합니다.
    -> 인터페이스 정의: 공개 구조체는 모듈의 공개 API의 일부가 되어, 다른 코드에서 사용할 수 있는 인터페이스를 정의합니다.
    -> 모듈 시스템 통합: pub struct는 Rust의 모듈 시스템과 긴밀히 연계되어, 코드의 구조화와 캡슐화를 돕습니다.

#####20250122#####
텔레메트리 데이터 : 알려지지 않은 알려지지 않은 것을 이해하고 디버그하는 데 의존할 수 있는 유일한 것

관측가능성 : 여러분의 환경에 관해 임의로 질문을 던질 수 있는 속성. 가장 중요한 것은 여러분이 무엇을 진물하기 원하는지 미리 알 필요가 없다는 점

move의 의미 
    : 소유권 이전 -> move 키워드는 클로저가 캡처하는 외부 변수들의 소유권을 클로저 내부로 이전시킵니다
        스레드 안전성 -> HttpServer는 여러 스레드에서 실행될 수 있으므로, 
        move를 사용하여 클로저가 캡처하는 모든 값의 소유권을 가져가 스레드 간 안전한 데이터 공유를 보장합니다
        변수 사용 제한 -> move 이후에는 클로저 외부에서 이동된 변수들을 더 이상 사용할 수 없습니다. 이는 데이터 레이스와 같은 동시성 문제를 방지합니다

클로저 : 러스트에서 환경을 캡처할 수 있는 익명 함수입니다

퍼사드 패턴 : log 크레이트가 사용해서 이중성 처리 / 복잡한 시스템이나 서브시스템에 대해 간단하고 통합된 인터페이스를 제공하는 구조적 디자인 패턴
    -> 퍼사드 패턴은 복잡한 시스템의 내부 작동을 숨기고, 클라이언트에게 간단한 인터페이스를 제공

트레이싱(tracing) : 로깅 스타일의 확장된 진단 정보. 라이브러리와 애플리케이션은 시간적 인과 관계에 관한 추가적인 정보와 함께 구조화된 이벤트를 기록할 수 있다.
    로그 메지시와 달리 트레이싱의 범위는 시작과 종료 시간을 가지며 실행 흐름에 의해 진입 및 이탈할 수 있고, 유사한 범위의 중첩된 트리 안에 존재할 수 있다.

#####20250123#####
tatcing-subscriber : tracing 프로젝트에서 유지 보수되고 있는 다른 크레이트  
    layer 라는 또 다른 핵심적인 트레이트를 제공 -> 사용 시 데이터에 관한 '처리 파이프라인'을 만들 수 있다.
 
 registry : trace 자체를 기록하지 않음 대신 그것을 감싸는 레이어에 노출되는 span데이터를 수집하고 저장한다. (저장,기록 활성화 / 종료 된 span의 추적을 담당)

 for<'a>MakeWriter<'a> : for<'a>는 모든 가능한 라이프타임 'a에 대해 MakeWriter<'a> 트레이트를 구현해야 함을 나타냅니다. 이는 다음과 같은 특징을 가집니다

 ######20250125######
 배포를 위해 이 책에서는 '디지철오션'을 사용한다.
    1. 깃 저장소의 루드에 Dockerfile을 생성한다.
    2. docker build --tag zero2prod --file Dockerfile .  명령어 실행 
        -> '.' 의 의미 : 'docker build'는 레시피(도커 파일) 와 빌드 콘텍스트 로부터 이미지를 생성한다 (도커 이미지는 그 자체로 완전히 고립된 환경으로 볼수 있음)
        -> 이미지와 로컬머신을 연결하는 접점은 COPY 와 ADD 같은 명령어 뿐 -> 빌드 콘텍스트는 호트스 머신의 어떤 파일들이 도커 컨테이너 안에서 COPY 할 수 있거나 그 친구들에게 보이는지 결정
        -> '.'은 도커 이미지에 현재 디렉터리를 해당 이미지의 빌드 콘텍스트로 사용하라고 알린다.
    3. Cargo.toml "offline" 추가 -> cargo sqlx prepare -- --lib 명령어 입력
        -> prepare : cargo build가 호출되었을 때와 일반적으로 동일한 작업을 하지만 쿼리의 결과를 메타데이터 파일(sqlx-data.json)에 저장한다. 이후 sqlx가 발견하며,
            모든 쿼리를 스킵하고 오프라인 빌드를 수행하기 위해 사용된다.

기본적으로 도커 이미지는 기반 호스트 머신에 포트를 노출하지 않는다. 포트를 노출하려면 명시적으로 -p 플래그를 사용해야 한다.
    -> docker run -p 8080:8080 zero2prod

######20250127######
도커 이미지 최적화
    -> 더 빠른 사용을 위한 작은 이미지 크기 / 더 빠른 빌드를 위한 도커 레이어 캐싱

이미지 크기
    -> docker images [프로젝트명] : 도커 이미지 정보
    -> docker images rust[버전] : 러스트 이미지 정보

    -> 러스트 장점 : 러스트의 바이너리는 정적으로 링크되어 있다. 바이너리를 실행하기 위해 소스 코드나 중간 컴파일 산출물을 유지할 필요가 없다.
         다단계 빌드에서 잘 작동하며, 이는 유용한 '도커 피처'다. (빌드는 두 단계로 나눔)
             -> builder 단계 : 컴파일된 바이너리를 생성한다. / runtime 단계 : 바이너리를 실행한다.
             -> Dockerfile - Runtime stage 파트 : FROM rust:1.84.0-slim AS runtime (러스트 툴체인과 용병의 무게를 줄임 - 이들은 바이너리를 실행하는데 필요없음)
                -> 20250127(2:46) FROM debian:bullseye_slim AS runtime으로 대체 (COPY파트 전 까지 해당 파트 추가로 생긴 부분)

    -> 더 작은 크기의 도커 이미지를 만드는데 관심이 있으면 'rust-musl-builder'를 참조 혹은 심벌을 '제거'하는 것이다 (갓허브 저장소 참조)

레이커 캐싱
    -> 도커 파일의 RUN, COPY, ADD 명령은 각각 하나의 레이어를 생성. 레이어는 현재 상태(이전 위쪽 레이어)와 지정한 명령을 수행한 뒤의 현재 상태의 차이
    -> 레이어들은 캐시됨. 동작의 시작 시점이 변경되지 않고, 명령어 자체가 변경되지 않으면 도커는 아무런 계산도 수행 안하고 캐시 결과의 사본을 그대로 꺼낸다.
        -> 도커 레이어 캐싱은 매우 빠르며, 이를 활요하면 도커 빌드의 속도를 현저하게 높일수 있음 -> 그 방법은 도커 파일의 동작 순서를 최적화 하는것
    -> 다단계 빌드에서 상호작용하는 방법의 장점을 가진다.
    -> 1. 레시피 파일을 계산 / 2. 디펜던시를 캐싱한 뒤 바이너리를 빌드 / 3. 런타임 환경


######20250131######
& : 불변 참조 생성 / 소유권 이전 방지 / 메모리 효율성 / 안전성 보장 / 함수 인자 전달

검증 함수 : 프로그램의 실행 흐름 중 어느 시점에서 특정 조건군이 검증된 것을 뜻함 -> 입력 데이터 안의 추가적인 구조체에 관한 이 정보는 어디에도 저장되지 않음
파싱 함수 : 구조화되어 있지 않은 입력을 받아, 일련의 조건이 만족되면, 더욱 구조화된 출력을 반환하는 루틴
타입 주도 개발 : 모델링 하고자 하는 도메인의 제약 사항을 타입 시스템 안에 인코딩하는 강력한 접근 방식이며, 컴파일러를 통해 이들이 강제되고 있는지 확인 가능
    -> 프로그래밍 언어의 타입 시스템이 가진 표현력이 높을수록, 더 강력하게 우리가 작업하는 domain에 유효한 상태들만 코드로 표현할 수 있도록 제약 가능

panic(패닉) : 회복할 수 없는 오류를 다룰 떄 사용. 기대하지 않았거나 의미 있게 회복할 방법이 없는 실패모드
    -> 호스트 머신의 메모리가 부족하거나 디스크가 가득 찬 상황 등을 포함