##20250116######
클라우드 네이티브 : 클라우드 컴퓨팅 환경에서 현대적인 애플리케이션을 구축, 배포 및 관리하는 소프트웨어 접근 방식입니다

*** main.rs 구문 ***

use actix_web::{web, App, HttpRequest, HttpServer, Responder};

async fn greet(req: HttpRequest) -> impl Responder {
    let name = req.match_info().get("name").unwrap_or("World");
    format!("Hello!!!! {}!", &name)
}

#[tokio:: main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/", web::get().to(greet))
            .route("/{name}", web::get().to(greet))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

HttpServer 의 역할 : 모든 전송 계층의 고려 사항을 처리한다 
    -> ( ex. 애플리케이션이 유입되는 요청을 어디서 받는가? / 허가 할 수 있는 동시 연결의 최대수(단위 시간당 얼마나 많은 신규 커넥션을 유지 한는가) / 전송 계층 보안 활성화 등 )

App의 역할 : 애플리케이션 로직(라우팅, 미들웨어, 요청 핸들러) 동작 하는 곳. 유입요청을 입력으로 받아 응답을 출력하는 컴포넌트
    -> App에 새로운 앤드포인트를 추가하는 방법
        : 간단한 방법 -> "route" 사용 
            -> route는 두개의 파라미터 받음, 하나의 핸들러(handler)와 일련의 가드(guard) 조합 
            ( path : 문자열이며 동적 경로 세그먼트를 수용하기 위해 템플릿화 ex."/{name}" , route : Route 구조체의 인스턴스 )
            , 가드는 핸들러에 전달되기 위해 만족할 수 있고 여청이 일치하는 조건을 지정 ( Guard 트레이드 )
                , .route("/", web::get().to(great))의 의미 
                    : "/"는 베이스경로에 아무런 세그먼트를 갖지 않는 모든 요청과 일치한다.
                    web::get().to(great)는 Route::new().guard(guard:Get())를 간략하게 표현한것 즉 요청은 GET일때만 핸들어에 전달되어야함
            , 핸들러 일단은 예시로 greet( 비동기 함수, HttpRequest를 입력받아 Responder 트레이트를 구현한 무언가를 반환, 타입은 HttpRespomse로 변환할 수 있을때만 구현 )만 사용

앤드포인트

런타임: tokio (절차적 매크로 procedural macro)
    : 비동기 트로그래밍은 Future trait위에 만들어짐 -> 모든 퓨처는 하나의 poll메서드를 노출 이를 호출 시 퓨처가 진행되어 최종값을 갖게됨
    , main은 비동기여야 한다(HttpServer::run은 비동기 메서드이기 때문) 하지만 바이너리의 엔트리 포인트인 main은 비동기 함수가 될수 없음
        -> 이유 : 설계상 러스트의 표준 라이브러리는 비동기적인 런타임을 포함하지 않음 의존성을 추가해야 된다면 Cargo.toml 아래에 하나 이상의 크레이트를 추가해야됨, 유스케이스의 측정한 요구 사항에 최적화된 런타임 직접 구현 가능
        -> 이러한 이유로 main은 비동기 함수가 될수 없음

리그레션 : 새로운 기능의 추가 혹은 수정으로 인해 과거에 개발한 기능의 동작에 이상이 발생하는 것을 나타낸다

블랙박스테스트 : 주어진 입력값에 대한 출력값을 확인함으로써 시스템의 동작을 검증

라이브러리 와 바이너리 
        cargo의 기본동작은 다른 코드를 추가하지 않으면 src/main.rs파일을 바이너리 엔트리 포은트로 검색하고, package.name 필드를 바이너리 이름으로 사용

테스트 작성 ( 총 3가지)
    1. 내장 테스트 모듈 사용 ( 코드 옆에 작성 ) -> #[cfg(test)] 선언 -> 가까이 있는 코드 접근에 대한 특권을 가짐 / 의존성으로 임포트 시 코드 사용자들에게 보이지 않음
    2. 외부 test 폴더에 작성              
    3. 공개 문서의 일부로 작성(doc test)

###20250118####
테이블 주도 테스트(파라미터화 테스트)

추출자 (actix-web 사용자가이드) : 유입되는 요청으로부터 특정한 정보를 추출하도록 프레임워크에게 지시할 때 사용

serde : 러스트 데이터 구조를 효율적이고 제네릭하게 직력화/역직렬화하기 위한 프레임워크
    -> 내가 구현한 타입이 Serialize를 일단 구현하면, Serializer의 구체적인 구현을 사용해서 실제로 직렬화 단계를 수행할 수 있다 (어떤 포맷이든지)
    -> 단일화 라고 불리는 프로세스 덕분에 효율적으로 사용할 수 있다.

####20250120####
PostgressSQL -> 관계형 데이터베이스
    -> tokio-postgres : 런타임에 쿼리를 실행시 오류 발생확인 (쿼리 직접 기술 -> 비동기 인터페이스)
    -> sqlx : 사용자 절차 매크로를 사용해서 컴파일-시간에 데이터베이스에 연결하고 제공된 퀄리가 실제로 올바른지 확인 (쿼리 직접 기술 -> 비동기 인터페이스)
    -> diesel : CLI를 활요해서 데이터베이스 스키마 표현을 러스트 코드처럼 생성 이를 활요해 쿼리에 대한 가정을 확인 (고유한 쿼리 필터 제공 -> 도메인 특화 언어 -> 동기 인터페이스)

데이터 마이그레이션 : 데이터베이스에 새로운 테이블을 추가하려면 스키마를 변경

마이그레이션 생성 하는 명령어
export DATABASE_URL=postgres://postgres:password@127.0.0.1:5432/newsletter
sqlx migrate add create_subscriptions_table