######20250116######
클라우드 네이티브 : 클라우드 컴퓨팅 환경에서 현대적인 애플리케이션을 구축, 배포 및 관리하는 소프트웨어 접근 방식입니다

*** main.rs 구문 ***

use actix_web::{web, App, HttpRequest, HttpServer, Responder};

async fn greet(req: HttpRequest) -> impl Responder {
    let name = req.match_info().get("name").unwrap_or("World");
    format!("Hello!!!! {}!", &name)
}

#[tokio:: main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/", web::get().to(greet))
            .route("/{name}", web::get().to(greet))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

HttpServer 의 역할 : 모든 전송 계층의 고려 사항을 처리한다 
    -> ( ex. 애플리케이션이 유입되는 요청을 어디서 받는가? / 허가 할 수 있는 동시 연결의 최대수(단위 시간당 얼마나 많은 신규 커넥션을 유지 한는가) / 전송 계층 보안 활성화 등 )

App의 역할 : 애플리케이션 로직(라우팅, 미들웨어, 요청 핸들러) 동작 하는 곳. 유입요청을 입력으로 받아 응답을 출력하는 컴포넌트
    -> App에 새로운 앤드포인트를 추가하는 방법
        : 간단한 방법 -> "route" 사용 
            -> route는 두개의 파라미터 받음, 하나의 핸들러(handler)와 일련의 가드(guard) 조합 
            ( path : 문자열이며 동적 경로 세그먼트를 수용하기 위해 템플릿화 ex."/{name}" , route : Route 구조체의 인스턴스 )
            , 가드는 핸들러에 전달되기 위해 만족할 수 있고 여청이 일치하는 조건을 지정 ( Guard 트레이드 )
                , .route("/", web::get().to(great))의 의미 
                    : "/"는 베이스경로에 아무런 세그먼트를 갖지 않는 모든 요청과 일치한다.
                    web::get().to(great)는 Route::new().guard(guard:Get())를 간략하게 표현한것 즉 요청은 GET일때만 핸들어에 전달되어야함
            , 핸들러 일단은 예시로 greet( 비동기 함수, HttpRequest를 입력받아 Responder 트레이트를 구현한 무언가를 반환, 타입은 HttpRespomse로 변환할 수 있을때만 구현 )만 사용

런타임: tokio (절차적 매크로 procedural macro)
    : 비동기 트로그래밍은 Future trait위에 만들어짐 -> 모든 퓨처는 하나의 poll메서드를 노출 이를 호출 시 퓨처가 진행되어 최종값을 갖게됨
    , main은 비동기여야 한다(HttpServer::run은 비동기 메서드이기 때문) 하지만 바이너리의 엔트리 포인트인 main은 비동기 함수가 될수 없음
        -> 이유 : 설계상 러스트의 표준 라이브러리는 비동기적인 런타임을 포함하지 않음 의존성을 추가해야 된다면 Cargo.toml 아래에 하나 이상의 크레이트를 추가해야됨, 유스케이스의 측정한 요구 사항에 최적화된 런타임 직접 구현 가능
        -> 이러한 이유로 main은 비동기 함수가 될수 없음

리그레션 : 새로운 기능의 추가 혹은 수정으로 인해 과거에 개발한 기능의 동작에 이상이 발생하는 것을 나타낸다

블랙박스테스트 : 주어진 입력값에 대한 출력값을 확인함으로써 시스템의 동작을 검증

라이브러리 와 바이너리 
        cargo의 기본동작은 다른 코드를 추가하지 않으면 src/main.rs파일을 바이너리 엔트리 포은트로 검색하고, package.name 필드를 바이너리 이름으로 사용
        
Rust 바이너리의 엔트리 포인트는 프로그램 실행이 시작되는 지점을 의미합니다.

Rust에서 라이브러리와 바이너리 프로젝트를 리팩토링할 때 고려해야 할 몇 가지 중요한 사항들이 있습니다:
구조 개선
    -> 관심사 분리: main 함수에서 여러 작업을 수행하는 대신, 로직을 lib.rs로 옮기고 main.rs는 설정과 실행에만 집중하도록 합니다
    -> 모듈화: 기능별로 코드를 모듈로 분리하여 유지보수성을 높입니다. 단, 과도한 중첩은 피하고 필요에 따라 점진적으로 모듈을 나눕니다
    -> 공개 API 설계: 라이브러리 사용자를 위해 간단하고 평평한 네임스페이스를 제공하되, 내부 구현은 계층적으로 구성할 수 있습니다
코드 품질 향상
    -> 트레이트 활용: 복잡한 트레이트 바운드는 피하고, 필요한 경우에만 적절히 사용합니다
    -> 매크로 사용 제한: 보일러플레이트 코드에만 매크로를 사용하고, 과도한 사용은 피합니다
    -> clone 사용: 성능에 큰 영향이 없다면, 복잡한 라이프타임 처리보다 clone을 사용하는 것이 코드 가독성을 높일 수 있습니다
도구 활용
    -> rustfmt와 clippy 사용: 일관된 코드 스타일을 유지하고 일반적인 실수를 방지합니다
    -> IDE 리팩토링 도구 활용: 변수나 함수 이름 변경 시 IDE의 리팩토링 기능을 사용하여 안전하게 변경합니다
점진적 접근
    -> 큰 변경은 점진적으로 수행: 필요성을 발견하면 먼저 리팩토링을 통해 교체를 쉽게 만들고, 그 후에 변경을 적용합니다
    -> ㅍ테스트 작성: 리팩토링 전후로 테스트를 작성하여 기능이 올바르게 동작하는지 확인합니다.

테스트 작성 ( 총 3가지)
    1. 내장 테스트 모듈 사용 ( 코드 옆에 작성 ) -> #[cfg(test)] 선언 -> 가까이 있는 코드 접근에 대한 특권을 가짐 / 의존성으로 임포트 시 코드 사용자들에게 보이지 않음
    2. 외부 test 폴더에 작성              
    3. 공개 문서의 일부로 작성(doc test)

#####20250118#####
테이블 주도 테스트(파라미터화 테스트)

추출자 (actix-web 사용자가이드) : 유입되는 요청으로부터 특정한 정보를 추출하도록 프레임워크에게 지시할 때 사용

serde : 러스트 데이터 구조를 효율적이고 제네릭하게 직력화/역직렬화하기 위한 프레임워크
    -> 내가 구현한 타입이 Serialize를 일단 구현하면, Serializer의 구체적인 구현을 사용해서 실제로 직렬화 단계를 수행할 수 있다 (어떤 포맷이든지)
    -> 단일화 라고 불리는 프로세스 덕분에 효율적으로 사용할 수 있다.

#####20250120#####
PostgressSQL -> 관계형 데이터베이스
    -> tokio-postgres : 런타임에 쿼리를 실행시 오류 발생확인 (쿼리 직접 기술 -> 비동기 인터페이스)
    -> sqlx : 사용자 절차 매크로를 사용해서 컴파일-시간에 데이터베이스에 연결하고 제공된 퀄리가 실제로 올바른지 확인 (쿼리 직접 기술 -> 비동기 인터페이스)
    -> diesel : CLI를 활요해서 데이터베이스 스키마 표현을 러스트 코드처럼 생성 이를 활요해 쿼리에 대한 가정을 확인 (고유한 쿼리 필터 제공 -> 도메인 특화 언어 -> 동기 인터페이스)

데이터 마이그레이션 : 데이터베이스에 새로운 테이블을 추가하려면 스키마를 변경

마이그레이션 생성 하는 명령어
export DATABASE_URL=postgres://postgres:password@127.0.0.1:5432/newsletter
sqlx migrate add create_subscriptions_table

#####20250121#####
let mut #name# mut의 의미 : 변수가 가변임을 명시적으로 선언 -> rust에서 변수는 기본적으로 불변 이므로 변수가 가변으로 선언이 필요할 경우 mut를 사용한다.

PgConnection::connect : 단일 연결 문자열을 입력받음 / DatabaseSettings : 모든 연결 파라미터에 각각 접근 가능

sqlx : sqlx_cli 명령어와 마찬가지로, DATABASE_URL 환경변수에 의존해서 데이터베이스의 위치를 찾는다. 
    -> DATABASE_URL은 수동으로 익스포트할 수 있다. 하지만 머신을 부팅하고 프로잭트에서 작업을 시작할 때마다 같은 작업을 해야 한다
    -> 그러므로 최상위 레벨의 .env 파일에 다음을 추가한다.


PgConnection의 동시성 이슈 -> sqlx은 비동기 인터페이스 하지만 같은 데이터베이스 커넥션에 대해 동시에 여러 쿼리를 실행할 수 없다.

Rust에서 pub struct는 공개(public) 구조체를 선언하는 키워드입니다.
    -> 가시성: pub 키워드는 해당 구조체를 모듈 외부에서 접근 가능하게 만듭니다. 이는 다른 모듈이나 크레이트에서 이 구조체를 사용할 수 있음을 의미합니다.
    -> 데이터 캡슐화: 구조체 자체는 공개되지만, 구조체의 필드는 기본적으로 비공개(private)입니다. 필드를 공개하려면 각 필드에 pub 키워드를 추가해야 합니다.
    -> 인터페이스 정의: 공개 구조체는 모듈의 공개 API의 일부가 되어, 다른 코드에서 사용할 수 있는 인터페이스를 정의합니다.
    -> 모듈 시스템 통합: pub struct는 Rust의 모듈 시스템과 긴밀히 연계되어, 코드의 구조화와 캡슐화를 돕습니다.

#####20250122#####
텔레메트리 데이터 : 알려지지 않은 알려지지 않은 것을 이해하고 디버그하는 데 의존할 수 있는 유일한 것

관측가능성 : 여러분의 환경에 관해 임의로 질문을 던질 수 있는 속성. 가장 중요한 것은 여러분이 무엇을 진물하기 원하는지 미리 알 필요가 없다는 점

move의 의미 
    : 소유권 이전 -> move 키워드는 클로저가 캡처하는 외부 변수들의 소유권을 클로저 내부로 이전시킵니다
        스레드 안전성 -> HttpServer는 여러 스레드에서 실행될 수 있으므로, 
        move를 사용하여 클로저가 캡처하는 모든 값의 소유권을 가져가 스레드 간 안전한 데이터 공유를 보장합니다
        변수 사용 제한 -> move 이후에는 클로저 외부에서 이동된 변수들을 더 이상 사용할 수 없습니다. 이는 데이터 레이스와 같은 동시성 문제를 방지합니다

클로저 : 러스트에서 환경을 캡처할 수 있는 익명 함수입니다

퍼사드 패턴 : log 크레이트가 사용해서 이중성 처리

트레이싱(tracing) : 로깅 스타일의 확장된 진단 정보. 라이브러리와 애플리케이션은 시간적 인과 관계에 관한 추가적인 정보와 함께 구조화된 이벤트를 기록할 수 있다.
    로그 메지시와 달리 트레이싱의 범위는 시작과 종료 시간을 가지며 실행 흐름에 의해 진입 및 이탈할 수 있고, 유사한 범위의 중첩된 트리 안에 존재할 수 있다.